#pragma once
#include "base_solver.h"
//------------------------------------------------------------------------
#define REQ_OK 0         // успешное завершение работы решателя

#define REQ_MULT_MV 1    // требуется умножить матрицу на вектор
#define REQ_MULT_L 2     // требуется умножить вектор на левый предобусловливатель
#define REQ_MULT_U 3     // требуется умножить вектор на правый предобусловливатель
#define REQ_SOLVE_L 4    // требуется решить систему с левым предобусловливателем
#define REQ_SOLVE_U 5    // требуется решить систему с правым предобусловливателем
#define REQ_PRECOND 6    // требуется решить предобусловленную систему
#define REQ_STOP_TEST 7  // требуется запустить критерий остановки решателя 
#define REQ_X0_TEST 8    // требуется проверить является ли уже начальное приближение решением	

#define REQ_MULT_MV_TRANSP 9    // требуется умножить транспонированную матрицу на вектор
#define REQ_SOLVE_L_TRANSP 10   // 
#define REQ_SOLVE_U_TRANSP 11   // 

#define REQ_GET_VECTOR 12 // требуется подать следующий вектор (направление для минимизации)

#define REQ_X0_NULL -1     // начальное приближение уже является решением
#define REQ_DIV_BY_ZERO -2 // внутри решателя произошло деление на ноль
#define REQ_MAXITER -3     // аварийный выход по достижении максимального количества итераций

//------------------------------------------------------------------------
class RCI
{
protected:
	// переменные, необходимые для функционирования механизма RCI

	int request; // параметр, информирующий о результате работы решателя:
	// request<0 - решатель завершил работу с ошибкой; 
	// request=REQ_OK - успешное завершение работы.
	// Положительное значение указывает, что пользователь должен выполнить определенные действия.

	int stage;   // содержит информацию о том, на каком этапе находится решатель

	double **in;   // вектор, на который необходимо умножить матрицу или подействовать предобусловливателем
	double **out;  // результат умножения матрцы на вектор или предобусловленный вектор 

public:

	// переменные, которые есть во всех решателях
	int n;       // размерность СЛАУ
	int nb;      // блочная размерность СЛАУ
	double *x;   // аппроксимация вектора решения на текущей итерации
	double *pr;  // вектор правой части
	Base_solver bs;


	// переменные, необходимые для критериев остановки решателя
	int iter;     // номер текущей итерации
	int maxiter;  // максимальное число итераций
	double eps;   // точность решения СЛАУ (норма относительной невязки)
	double r_old; // норма истинной невязки перед началом счёта
	double eps_x0;      // точность для проверки, является ли уже начальное приближение решением
	double eps_zero;    // сравнение с нулем для аварийного выхода
	double residual;    // норма невязки на текущей итерации
	double residualRel; // норма относительной невязки
	double eps_gmres;

public:
	virtual int Run()=0;

	void PrintIterResidual();
	void DoStopTest(double *r, int *req);
	void DoStopTest(double r, int *req);
	void DoX0Test(double *r, int *req);

	RCI(int n, int maxiter, double eps, double *x, double *pr, double **in, double **out);
	~RCI();
};
//------------------------------------------------------------------------




