#pragma once

//-------------------------------------------------------------------------
/*	Структура long_double требуется при построении T-матрицы.
В ней хранится номер базисной функции и значение, с которым она берётся.
Удобно хранить эти два числа вместе.
*/
//-------------------------------------------------------------------------
struct long_double
{
	long i;
	double d;
};
//-------------------------------------------------------------------------
// Бинарное дерево используется для хранения "цепочек" номеров базисных функций
// при построении T-матрицы
//-------------------------------------------------------------------------
class Btree
{
public:
	long elem_long;
	double elem_double;
	bool visited;
	Btree *left, *right;
	
	Btree();
	Btree(long elem_long, double elem_double);
	~Btree();

	int DeleteTree(Btree *t);
	int Add_Left(long elem_long, double elem_double);
	int Add_Right(long elem_long, double elem_double);
	Btree * visit(std::vector<long_double> *s_t, Btree *t, long j);
};
//--------------------------------------------------------------------------------------------------------------
// Класс T_Mapping_Vec служит для построения Т-матрицы для векторных (edge-elements)
// шестигранников и нумерации рёбер в узловой сетке.
//
// Здесь используются векторные базисные функции с тангенциальными составляющими 2/hx, 2/hy, 2/hz вдоль рёбер,
// поэтому сумма по столбцу в T-матрице вообще не равна 1, и проводить такую проверку бессмысленно.
//--------------------------------------------------------------------------------------------------------------
class T_Mapping_Vec
{
public: 
	T_Mapping_Vec(long (*nver)[14], double (*xyz)[3], long kuzlov, long kpar);
	~T_Mapping_Vec();

	// матрица перехода в разреженном столбцовом формате
	long *ig_t; 
	long *jg_t;
	double *gg_t;

	long *ig_s, *jg_s; // структура SIGMA (вспомогательная структура для T-матрицы)
	double *s_val;     // значения, к-рые потребуются для формирования всех ненулевых компонент матрицы T 

	long n_c;  // число непрерывных функций (continuous)
	long n_dc; // число разрывных функций (discontinuous)
	long n;    // всего функций n = n_c + n_dc

	long kuzlov; // кол-во узлов в сетке
	long kpar;   // кол-во параллелепипедов
	long (*nver)[14]; // ячейки перечисленные своими узлами + терминальные узлы + тип эл-та
	double (*xyz)[3]; // координаты вершин (всех вместе)

	long (*edges)[2]; // рёбра, заданные 2-мя вершинами
	long (*ed)[25];   // ячейки перечисленные своими рёбрами + терминальные рёбра + тип эл-та  !!!!! НЕ ХОРОШО - тип хранится дважды

	//--------------------------------------------------------------------------------------
	// для A-V постановки
	// реберные
	long edges_c;  // число непрерывных функций (continuous)
	long edges_dc; // число разрывных функций (discontinuous)
	long edges_all;    // всего функций edges_all = edges_c + edges_dc
	// узловые
	long nodes_c;  // число непрерывных функций (continuous)
	long nodes_dc; // число разрывных функций (discontinuous)
	long nodes_all;    // всего функций nodes_all = nodes_c + nodes_dc
	// неизвестные
	long unk_all;

	long *nvkat;
	long *m_nded;		// m_nded - массив для хранения номеров неизвестных (узлов и ребер)
	long *m_nded_type;	// 0 - узел, 1 - ребро
	long (*nvetr)[20];	// элементы перечисленные своими узлами и ребрами в нумерации соответствующей m_nded
	// 1-8  - номера узлов в массиве m_nded
	// 9-20 - номера ребер в массиве m_nded
	long *nodes_position_in_nded;	// позиции узлов в массиве m_nded
	long *edges_position_in_nded;	// позиции ребер в массиве m_nded
	bool *nodes_earth; // 0 - узел лежит в воздухе, 1 - в земле
	int Form_data_A_V(long *nvkat);

	// узловая матрица перехода в разреженном столбцовом формате
	long *ig_t_nodes; 
	long *jg_t_nodes;
	double *gg_t_nodes;
	// реберная матрица перехода в разреженном столбцовом формате
	long *ig_t_edges; 
	long *jg_t_edges;
	double *gg_t_edges;
	void LoadTmatrices();
	//------------------------------------------------------------------------------------------------------------------------------


	int Enumerate_Edges_In_Nonconforming_Mesh(); // нумерация рёбер в узловой сетке (генерация edges, ed)
	int Build_Sigma_Stucture(); // создание ig_s, jg_s, s_val
	int Build_T_Matrix();       // генерация матрицы T (окончательная)

	// строит цепочку номеров рёбер, необходимых для вычисления 
	// последующих ненулевых компонент столбца j
	Btree* Build_Sequence(long e, double value);

	// сформировать вектор весов во всех рёбрах (и в терминальных, и в нетерминальных)
	int CalcValuesAll(double *v3_c, double *v3_all);
	int CalcValuesAll(double *v3); // дописывает в конец

	int UnloadVMesh();
};
//--------------------------------------------------------------------------------------------------